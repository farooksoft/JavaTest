<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0043)http://en.wikipedia.org/wiki/Virtual_memory -->
<HTML lang=en dir=ltr xml:lang="en" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Virtual memory - Wikipedia, the free encyclopedia</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META 
content="Virtual memory,1959,1962,1969,1992,Address space,Apple Macintosh,Application software,Atlas Computer,BSOD,CPU cache" 
name=keywords><LINK href="/favicon.ico" rel="shortcut icon"><LINK 
href="http://www.gnu.org/copyleft/fdl.html" rel=copyright>
<STYLE type=text/css media=screen,projection>@import url( /skins-1.5/monobook/main.css?5 );
</STYLE>
<LINK media=print 
href="Virtual memory - Wikipedia, the free encyclopedia_files/commonPrint.css" 
type=text/css rel=stylesheet><!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css";</style><![endif]--><!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css";</style><![endif]--><!--[if gte IE 6]>
<STYLE type=text/css>@import url( /skins-1.5/monobook/IE60Fixes.css );
</STYLE>
<![endif]--><!--[if IE]>
<SCRIPT src="Virtual memory - Wikipedia, the free encyclopedia_files/IEFixes.js" 
type=text/javascript></SCRIPT>

<META http-equiv=imagetoolbar content=no><![endif]-->
<SCRIPT src="Virtual memory - Wikipedia, the free encyclopedia_files/index.php" 
type=text/javascript><!-- site js --></SCRIPT>

<SCRIPT 
src="Virtual memory - Wikipedia, the free encyclopedia_files/wikibits.js" 
type=text/javascript><!-- wikibits js --></SCRIPT>

<STYLE type=text/css>@import url( /w/index.php?title=MediaWiki:Common.css&action=raw&ctype=text/css&smaxage=2678400 );
@import url( /w/index.php?title=MediaWiki:Monobook.css&action=raw&ctype=text/css&smaxage=2678400 );
@import url( /w/index.php?title=-&action=raw&gen=css&maxage=2678400 );
</STYLE>

<META content="MSHTML 6.00.2900.2722" name=GENERATOR></HEAD>
<BODY class=ns-0>
<DIV id=globalWrapper>
<DIV id=column-content>
<DIV id=content><A id=top name=top></A>
<DIV id=siteNotice>
<DIV style="FONT-SIZE: 80%; TEXT-ALIGN: right"><B>Wikipedia founder Jimmy 
Wales's <A class=extiw title="wikimedia:Personal Appeal" 
href="http://wikimediafoundation.org/wiki/Personal_Appeal">personal appeal for 
donations</A></B></DIV></DIV>
<H1 class=firstHeading>Virtual memory</H1>
<DIV id=bodyContent>
<H3 id=siteSub>From Wikipedia, the free encyclopedia.</H3>
<DIV id=contentSub></DIV>
<DIV id=jump-to-nav>Jump to: <A 
href="http://en.wikipedia.org/wiki/Virtual_memory#column-one">navigation</A>, <A 
href="http://en.wikipedia.org/wiki/Virtual_memory#searchInput">search</A></DIV><!-- start content -->
<DIV class="thumb tright">
<DIV style="WIDTH: 302px"><A class=internal 
title="The memory pages of the virtual address space seen by the process, may reside non-contiguously in primary, or even secondary storage." 
href="http://en.wikipedia.org/wiki/Image:Virtualmem.png"><IMG height=353 
alt="The memory pages of the virtual address space seen by the process, may reside non-contiguously in primary, or even secondary storage." 
src="Virtual memory - Wikipedia, the free encyclopedia_files/300px-Virtualmem.png" 
width=300 longDesc=/wiki/Image:Virtualmem.png></A> 
<DIV class=thumbcaption>
<DIV class=magnify style="FLOAT: right"><A class=internal title=Enlarge 
href="http://en.wikipedia.org/wiki/Image:Virtualmem.png"><IMG height=11 
alt=Enlarge 
src="Virtual memory - Wikipedia, the free encyclopedia_files/magnify-clip.png" 
width=15></A></DIV>The memory pages of the virtual address space seen by the 
process, may reside non-contiguously in primary, or even secondary 
storage.</DIV></DIV></DIV>
<P><B>Virtual memory</B> or <B>virtual memory addressing</B> is a memory 
management technique, used by <A title=Multitasking 
href="http://en.wikipedia.org/wiki/Multitasking">multitasking</A> <A 
title=Computer href="http://en.wikipedia.org/wiki/Computer">computer</A> <A 
title="Operating system" 
href="http://en.wikipedia.org/wiki/Operating_system">operating systems</A> 
wherein non-contiguous memory is presented to a software application (aka 
process) as contiguous memory. The contiguous memory is referred to as the <A 
title="Virtual address space" 
href="http://en.wikipedia.org/wiki/Virtual_address_space">virtual address 
space</A>.</P>
<P>Virtual memory addressing is typically used in <A title=Paging 
href="http://en.wikipedia.org/wiki/Paging">paged memory</A> systems. This in 
turn is often combined with memory swapping, whereby memory pages stored in <A 
title="Primary storage" 
href="http://en.wikipedia.org/wiki/Primary_storage">primary storage</A> are 
written to <A title="Secondary storage" 
href="http://en.wikipedia.org/wiki/Secondary_storage">secondary storage</A>, 
thus freeing faster primary storage for other processes to use.</P>
<P>The term "virtual memory" is often confused with "memory swapping" (or 
"page/swap file" use), probably due in part to the prolific Microsoft Windows 
family of operating systems referring to the enabling/disabling of memory 
swapping as virtual memory. In fact, Windows uses paged memory and virtual 
memory addressing, even if the so called "virtual memory" is disabled.</P>
<P>In technical terms, virtual memory allows software to run in a memory <A 
title="Address space" href="http://en.wikipedia.org/wiki/Address_space">address 
space</A> whose size and addressing are not necessarily tied to the computer's 
physical memory. To properly implement virtual memory the CPU (or a device 
attatched to it) must provide a way for the operating system to map virtual 
memory to physical memory and for it to detect when an address is required that 
does not currently relate to main memory so that the needed data can be swapped 
in. While it would certainly be possible to provide virtual memory without the 
CPU's assistance it would essentially require emulating a CPU that did provide 
the needed features.</P>
<TABLE class=toc id=toc summary=Contents>
  <TBODY>
  <TR>
    <TD>
      <DIV id=toctitle>
      <H2>Contents</H2></DIV>
      <UL>
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Background"><SPAN 
        class=tocnumber>1</SPAN> <SPAN class=toctext>Background</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Segmentation"><SPAN 
        class=tocnumber>2</SPAN> <SPAN class=toctext>Segmentation</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Basic_operation"><SPAN 
        class=tocnumber>3</SPAN> <SPAN class=toctext>Basic operation</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Details"><SPAN 
        class=tocnumber>4</SPAN> <SPAN class=toctext>Details</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Paging_and_virtual_memory"><SPAN 
        class=tocnumber>5</SPAN> <SPAN class=toctext>Paging and virtual 
        memory</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Additional_details"><SPAN 
        class=tocnumber>6</SPAN> <SPAN class=toctext>Additional 
        details</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#History"><SPAN 
        class=tocnumber>7</SPAN> <SPAN class=toctext>History</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Windows_example"><SPAN 
        class=tocnumber>8</SPAN> <SPAN class=toctext>Windows example</SPAN></A> 
        <UL>
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Virtual_memory#Misconceptions_about_the_Windows_page_file"><SPAN 
          class=tocnumber>8.1</SPAN> <SPAN class=toctext>Misconceptions about 
          the Windows page file</SPAN></A> </LI></UL>
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#Virtual_Memory_in_Linux"><SPAN 
        class=tocnumber>9</SPAN> <SPAN class=toctext>Virtual Memory in 
        Linux</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#See_also"><SPAN 
        class=tocnumber>10</SPAN> <SPAN class=toctext>See also</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#References"><SPAN 
        class=tocnumber>11</SPAN> <SPAN class=toctext>References</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Virtual_memory#External_links"><SPAN 
        class=tocnumber>12</SPAN> <SPAN class=toctext>External links</SPAN></A> 
        </LI></UL></TD></TR></TBODY></TABLE>
<P>
<SCRIPT type=text/javascript>
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</SCRIPT>
</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=1">edit</A>]</DIV>
<P><A id=Background name=Background></A></P>
<H2>Background</H2>
<P>Most computers possess four kinds of <A title="Memory (computers)" 
href="http://en.wikipedia.org/wiki/Memory_(computers)">memory</A>: <A 
title="Processor register" 
href="http://en.wikipedia.org/wiki/Processor_register">registers</A> in the CPU, 
<A title="CPU cache" href="http://en.wikipedia.org/wiki/CPU_cache">CPU 
caches</A> (generally some kind of <A title="Static RAM" 
href="http://en.wikipedia.org/wiki/Static_RAM">static RAM</A>) both inside and 
adjacent to the CPU, <A title="Main memory" 
href="http://en.wikipedia.org/wiki/Main_memory">main memory</A> (generally <A 
title="Dynamic RAM" href="http://en.wikipedia.org/wiki/Dynamic_RAM">dynamic 
RAM</A>) which the CPU can read and write to directly and reasonably quickly; 
and <A title="Disk storage" 
href="http://en.wikipedia.org/wiki/Disk_storage">disk storage</A>, which is much 
slower, but also much larger. CPU register use is generally handled by the 
compiler and this isn't a huge burden as data doesn't generally stay in them 
very long. The decision of when to use cache and when to use main memory is 
generally dealt with by hardware so generally both are regarded together by the 
programmer as simply <A title="Physical memory" 
href="http://en.wikipedia.org/wiki/Physical_memory">physical memory</A>.</P>
<P>Many <A title="Application software" 
href="http://en.wikipedia.org/wiki/Application_software">applications</A> 
require access to more information (<A title="Code (computer programming)" 
href="http://en.wikipedia.org/wiki/Code_(computer_programming)">code</A> as well 
as data) than can be stored in physical memory. This is especially true when the 
operating system allows multiple processes/<A title="Application software" 
href="http://en.wikipedia.org/wiki/Application_software">applications</A> to run 
seemingly in parallel. The obvious response to the problem of the maximum size 
of the physical memory being less than that required for all running programs is 
for the application to keep some of its information on the disk, and move it 
back and forth to physical memory as needed, but there are a number of ways to 
do this.</P>
<P>One option is for the application software itself to be responsible both for 
deciding which information is to be kept where, and also for moving it back and 
forth. The programmer would do this by determining which sections of the program 
(and also its data) were <A title="Mutually exclusive" 
href="http://en.wikipedia.org/wiki/Mutually_exclusive">mutually exclusive</A>, 
and then arranging for loading and unloading the appropriate sections from 
physical memory, as needed. The disadvantage of this approach is that each 
application's <A title=Programmer 
href="http://en.wikipedia.org/wiki/Programmer">programmer</A> must spend time 
and effort on designing, implementing, and <A title=Debugging 
href="http://en.wikipedia.org/wiki/Debugging">debugging</A> this mechanism, 
instead of focusing on his or her application; this hampers programmer's 
efficiency. Also, if any programmer could truly choose which of their items of 
data to store in the physical memory at any one time, they could easily conflict 
with the decisions made by another programmer, who also wanted to use all the 
available physical memory at that point.</P>
<P>Another option is to store some form of handles to data rather than direct 
pointers and let the OS deal with swapping the data associated with those 
handles between the swapfile and physical memory as needed. This works but has a 
couple of problems, namely that it complicates application code, that it 
requires applications to play nice (they generally need the power to lock the 
data into physical memory to actually work on it) and that it stops the 
languages standard library doing its own suballocations inside large blocks from 
the OS to improve performance. The best known example of this kind of 
arrangement is probably the <A title="Windows 3.x" 
href="http://en.wikipedia.org/wiki/Windows_3.x">16-bit versions of 
Windows</A>.</P>
<P>The modern solution is to use virtual memory, in which a combination of 
special <A title="Computer hardware" 
href="http://en.wikipedia.org/wiki/Computer_hardware">hardware</A> and <A 
title="Operating system" 
href="http://en.wikipedia.org/wiki/Operating_system">operating system</A> 
software makes use of both kinds of memory to make it look as if the computer 
has a much larger main memory than it actually does and to lay that space out 
differently at will. It does this in a way that is invisible to the rest of the 
software running on the computer. It usually provides the ability to simulate a 
main memory of almost any size (as limited by the size of the addresses being 
used by the operating system and cpu; the total size of the Virtual Memory can 
be 2<SUP>32</SUP> for a 32 bit system, or approximately 4 Gigabytes (though OS 
design decisions can make the amount available to applications in practice much 
less than this), while newer 64 bit chips and operating systems use 64 or 48 bit 
addresses and can index much more virtual memory).</P>
<P>This makes the job of the application programmer much simpler. No matter how 
much memory the application needs, it can act as if it has access to a main 
memory of that size and can place its data wherever in that virtual space that 
it likes. The programmer can also completely ignore the need to manage the 
moving of data back and forth between the different kinds of memory.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=2">edit</A>]</DIV>
<P><A id=Segmentation name=Segmentation></A></P>
<H2>Segmentation</H2>
<P>In <A title="Segmentation (memory)" 
href="http://en.wikipedia.org/wiki/Segmentation_(memory)">segmentation</A>, 
blocks of programs are of different sizes. Each block is known as a segment. 
Hence programs are divided into segments. The segment table is used to convert 
logical addresses into physical addresses. The operating system manages the 
segment table.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=3">edit</A>]</DIV>
<P><A id=Basic_operation name=Basic_operation></A></P>
<H2>Basic operation</H2>
<P>When virtual memory is used, or when a main memory location is read or 
written to by the CPU, hardware within the computer translates the address of 
the memory location generated by the software (the <I>virtual memory 
address</I>) into either:</P>
<UL>
  <LI>the address of a real memory location (the <I>physical memory address</I>) 
  which is assigned within the computer's physical memory to hold that memory 
  item, or 
  <LI>an indication that the desired memory item is not currently resident in 
  main memory (a so-called <I>virtual memory <A title=Exception 
  href="http://en.wikipedia.org/wiki/Exception">exception</A></I> or <A 
  title="Page fault" href="http://en.wikipedia.org/wiki/Page_fault">page 
  fault</A>) </LI></UL>
<P>In the former case, the memory reference operation is completed, just as if 
the virtual memory were not involved. In the latter case, the operating system 
is invoked to handle the situation, since the actions needed before the program 
can continue are usually quite complex.</P>
<P>The effect of this is to swap sections of information between the physical 
memory and the disk; the area of the disk which holds the information which is 
not currently in physical memory is called the <I>swap file</I> (OS/2, early 
Windowses, and others), <I>page file</I> (Windows), or <I>swap partition</I> (a 
dedicated partition of a hard disk, commonly seen in the Linux operating 
system).</P>
<P>Also on most modern systems <A title="Virtual address space" 
href="http://en.wikipedia.org/wiki/Virtual_address_space">virtual address 
space</A> can be mapped to disk storage other than the swapfile. This allows 
parts of executables to be paged in as needed direct from the executable saving 
the need to load the entire executable at application load time and reducing the 
demand for swap space. It also allows the operating system to keep one copy of 
an executable in memory at once rather than loading it separately for each 
running instance thereby reducing the pressure on physical memory.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=4">edit</A>]</DIV>
<P><A id=Details name=Details></A></P>
<H2>Details</H2>
<P>The translation from virtual to physical addresses is implemented by an <A 
title="Memory management unit" 
href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</A> (Memory 
Management Unit). This may be either a module of the CPU, or an auxiliary, 
closely coupled chip.</P>
<P>The operating system is responsible for deciding which parts of the program's 
simulated main memory are kept in physical memory. The operating system also 
maintains the translation tables which provide the mappings between virtual and 
physical addresses, for use by the MMU. Finally, when a virtual memory exception 
occurs, the operating system is responsible for allocating an area of physical 
memory to hold the missing information (and possibly in the process pushing 
something else out to disk), bringing the relevant information in from the disk, 
updating the translation tables, and finally resuming execution of the software 
that incurred the virtual memory exception.</P>
<P>In most computers, these translation tables are stored in physical memory. 
Therefore, a virtual memory reference might actually involve two or more 
physical memory references: one or more to retrieve the needed address 
translation from the page tables, and a final one to actually do the memory 
reference.</P>
<P>To minimize the performance penalty of address translation, most modern CPUs 
include an on-chip MMU, and maintain a table of recently used 
virtual-to-physical translations, called a <A 
title="Translation Lookaside Buffer" 
href="http://en.wikipedia.org/wiki/Translation_Lookaside_Buffer">Translation 
Lookaside Buffer</A>, or TLB. Addresses with entries in the TLB require no 
additional memory references (and therefore time) to translate, However, the TLB 
can only maintain a fixed number of mappings between virtual and physical 
addresses; when the needed translation is not resident in the TLB, action will 
have to be taken to load it in.</P>
<P>On some processors, this is performed entirely in hardware; the MMU has to do 
additional memory references to load the required translations from the 
translation tables, but no other action is needed. In other processors, 
assistance from the operating system is needed; an exception is raised, and on 
this exception, the operating system replaces one of the entries in the TLB with 
an entry from the translation table, and the instruction which made the original 
memory reference is restarted.</P>
<P>The hardware that supports virtual memory almost always supports memory 
protection mechanisms as well. The MMU may have the ability to vary its 
operation according to the type of memory reference (for read, write or 
execution), as well as the privilege mode of the CPU at the time the memory 
reference was made. This allows the operating system to protect its own code and 
data (such as the translation tables used for virtual memory) from corruption by 
an erroneous application program and to protect application programs from each 
other and (to some extent) from themselves (e.g. by preventing writes to areas 
of memory which contain code).</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=5">edit</A>]</DIV>
<P><A id=Paging_and_virtual_memory name=Paging_and_virtual_memory></A></P>
<H2>Paging and virtual memory</H2>
<P>Virtual memory is usually (but not necessarily) implemented using <A 
title=Paging href="http://en.wikipedia.org/wiki/Paging">paging</A>. In paging, 
the low order bits of the binary representation of the virtual address are 
preserved, and used directly as the low order bits of the actual physical 
address; the high order bits are treated as a key to one or more address 
translation tables, which provide the high order bits of the actual physical 
address.</P>
<P>For this reason a range of consecutive addresses in the <A 
title="Virtual address space" 
href="http://en.wikipedia.org/wiki/Virtual_address_space">virtual address 
space</A> whose size is a <A title="Power of two" 
href="http://en.wikipedia.org/wiki/Power_of_two">power of two</A> will be 
translated in a corresponding range of consecutive physical addresses. The 
memory referenced by such a range is called a <I>page</I>. The page size is 
typically in the range of 512 to 8192 bytes (with 4K currently being very 
common), though page sizes of 4 megabytes or larger may be used for special 
purposes. (Using the same or a related mechanism, contiguous regions of virtual 
memory larger than a page are often mappable to contiguous physical memory for 
purposes other than virtualization, such as setting access and caching control 
bits.)</P>
<P>The operating system stores the address translation tables, the mappings from 
virtual to physical page numbers, in a data structure known as a <A 
title="Page table" href="http://en.wikipedia.org/wiki/Page_table">page 
table</A>.</P>
<P>If a page that is marked as unavailable (perhaps because it is not present in 
physical memory, but instead is in the swap area), when the CPU tries to 
reference a memory location in that page, the MMU responds by raising an 
exception (commonly called a <I>page fault</I>) with the CPU, which then jumps 
to a routine in the operating system. If the page is in the swap area, this 
routine invokes an operation called a <I>page swap</I>, to bring in the required 
page.</P>
<P>The page swap operation involves a series of steps. First it selects a page 
in memory, for example, a page that has not been recently accessed and 
(preferably) has not been modified since it was last read from disk or the swap 
area. (See <A title="Page replacement algorithms" 
href="http://en.wikipedia.org/wiki/Page_replacement_algorithms">page replacement 
algorithms</A> for details.) If the page has been modified, the process writes 
the modified page to the swap area. The next step in the process is to read in 
the information in the needed page (the page corresponding to the virtual 
address the original program was trying to reference when the exception 
occurred) from the swap file. When the page has been read in, the tables for 
translating virtual addresses to physical addresses are updated to reflect the 
revised contents of the physical memory. Once the page swap completes, it exits, 
and the program is restarted and continues on as if nothing had happened, 
returning to the point in the program that caused the exception.</P>
<P>It is also possible that a virtual page was marked as unavailable because the 
page was never previously allocated. In such cases, a page of physical memory is 
allocated and filled with zeros, the page table is modified to describe it, and 
the program is restarted as above.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=6">edit</A>]</DIV>
<P><A id=Additional_details name=Additional_details></A></P>
<H2>Additional details</H2>
<P>One additional advantage of virtual memory is that it allows a computer to 
multiplex its CPU and memory between multiple programs without the need to 
perform expensive copying of the programs' memory images. If the combination of 
virtual memory system and operating system supports swapping, then the computer 
may be able to run simultaneous programs whose total size exceeds the available 
physical memory. Since most programs have a small subset (<I>active set</I>) of 
pages that they reference over significant periods of their execution, the 
performance penalty is less than that which might be expected. If too many 
programs are run at once, or if a single program continuously accesses widely 
scattered memory locations, then page swapping becomes excessively frequent and 
overall system performance will become unacceptably slow. This is often called 
<I>thrashing</I> (since the disk is being excessively overworked - thrashed) or 
<I>paging storm</I>, which corresponds to accessing the swap medium being three 
orders of magnitude slower compared to main memory access.</P>
<P>Note that virtual memory is not a requirement for precompilation of software, 
even if the software is to be executed on a multiprogramming system. Precompiled 
software loaded by the operating system has the opportunity to carry out address 
relocation at load time. This suffers by comparison with virtual memory in that 
a copy of program relocated at load time cannot run at a distinct address once 
it has started execution.</P>
<P>It is possible to avoid the overhead of address relocation using a process 
called <A title=Rebasing 
href="http://en.wikipedia.org/wiki/Rebasing">rebasing</A>, which uses metadata 
in the executable image header to guarantee to the run-time loader that the 
image will only run within a certain <A title="Virtual address space" 
href="http://en.wikipedia.org/wiki/Virtual_address_space">virtual address 
space</A>. This technique is used on the system libraries on Win32 platforms, 
for example.</P>
<P>Also many systems run multiple instances of the same program using the same 
physical copy of the program in physical memory but separate virtual address 
spaces. This is possible because the separate virtual address spaces can all 
have the same layout and thus avoid the need to relocate the code at load time. 
Some operating systems take this even further implementing <A 
title="Copy on write" href="http://en.wikipedia.org/wiki/Copy_on_write">copy on 
write</A> systems to allow a process to fork into two copies of itself without a 
complete copy of its data being created immediately.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=7">edit</A>]</DIV>
<P><A id=History name=History></A></P>
<H2>History</H2>
<P>Before the development of the virtual memory technique, programmers in the 
1940s and 1950s had to manage two-level storage (main memory or RAM, and 
secondary memory in the form of <A title="Hard disks" 
href="http://en.wikipedia.org/wiki/Hard_disks">hard disks</A> or earlier, <A 
title="Magnetic drum" href="http://en.wikipedia.org/wiki/Magnetic_drum">magnetic 
drums</A>) directly.</P>
<P>Virtual memory was developed in approximately <A title=1959 
href="http://en.wikipedia.org/wiki/1959">1959</A> - <A title=1962 
href="http://en.wikipedia.org/wiki/1962">1962</A>, at the <A 
title="University of Manchester" 
href="http://en.wikipedia.org/wiki/University_of_Manchester">University of 
Manchester</A> for the <A title="Atlas Computer" 
href="http://en.wikipedia.org/wiki/Atlas_Computer">Atlas Computer</A>, completed 
in <A title=1962 href="http://en.wikipedia.org/wiki/1962">1962</A>. However, 
Fritz-Rudolf Güntsch, one of Germany's pioneering computer scientists and later 
the developer of the <A title=Telefunken 
href="http://en.wikipedia.org/wiki/Telefunken">Telefunken</A> TR 440 mainframe, 
claims to have invented the concept in his doctoral dissertation <I>Logischer 
Entwurf eines digitalen Rechengerätes mit mehreren asynchron laufenden Trommeln 
und automatischem Schnellspeicherbetrieb</I> (Logic Concept of a Digital 
Computing Device with Multiple Asynchronous Drum Storage and Automatic Fast 
Memory Mode) in 1957.</P>
<P>Like many technologies in the history of computing, virtual memory was not 
accepted without challenge. Before it could be regarded as a stable entity, many 
models, experiments, and theories had to be developed to overcome the numerous 
problems with virtual memory. Specialized hardware had to be developed that 
would take a "virtual" address and translate it into an actual physical address 
in memory (secondary or primary). Some worried that this process would be 
expensive, hard to build, and take too much processor power to do the address 
translation.</P>
<P>By <A title=1969 href="http://en.wikipedia.org/wiki/1969">1969</A> the 
debates over virtual memory for commercial computers were over. An <A title=IBM 
href="http://en.wikipedia.org/wiki/IBM">IBM</A> research team, lead by David 
Sayre, showed that the virtual memory overlay system worked consistently better 
than the best manual-controlled systems.</P>
<P>In the 1970s, <A title=Minicomputer 
href="http://en.wikipedia.org/wiki/Minicomputer">minicomputer</A> models such as 
<A title=VAX href="http://en.wikipedia.org/wiki/VAX">VAX</A> models running <A 
title=OpenVMS href="http://en.wikipedia.org/wiki/OpenVMS">VMS</A> implemented 
virtual memory.</P>
<P>Nevertheless, early personal computers in the 1980s were developed without 
virtual memory, on the assumption that such issues would only apply to 
large-scale commercial computers. Virtual memory was introduced for <A 
title="Microsoft Windows" 
href="http://en.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</A> only 
in <A title="Windows 3.x" 
href="http://en.wikipedia.org/wiki/Windows_3.x">Windows 3.1</A> (1992), as 
described below, but available to <A title="Apple Macintosh" 
href="http://en.wikipedia.org/wiki/Apple_Macintosh">Apple Macintosh</A> starting 
with <A title="System 7 (Macintosh)" 
href="http://en.wikipedia.org/wiki/System_7_(Macintosh)">System 7</A> 
(1991).</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=8">edit</A>]</DIV>
<P><A id=Windows_example name=Windows_example></A></P>
<H2>Windows example</H2>
<P>Virtual memory has been a feature of <A title="Microsoft Windows" 
href="http://en.wikipedia.org/wiki/Microsoft_Windows">Microsoft Windows</A> 
since <A title="Windows 3.x" 
href="http://en.wikipedia.org/wiki/Windows_3.x">Windows 3.1</A> in <A title=1992 
href="http://en.wikipedia.org/wiki/1992">1992</A>. 386SPART.PAR (or WIN386.SWP 
on Windows 3.11 and Windows for Workgroups) is a hidden file created by Windows 
3.x for use as a virtual memory swap file. It is generally found in the <A 
title="Root directory" href="http://en.wikipedia.org/wiki/Root_directory">root 
directory</A>, but it may appear elsewhere (typically in the WINDOWS directory). 
Its size depends on how much virtual memory the system has set up under <A 
title="Windows Control Panel" 
href="http://en.wikipedia.org/wiki/Windows_Control_Panel">Control Panel</A> - 
Enhanced under "Virtual Memory." If a user moves or deletes this file, Windows 
will <A title=BSOD href="http://en.wikipedia.org/wiki/BSOD">BSOD</A> the next 
time it is started with "The permanent swap file is corrupt" and will ask the 
user if they want to delete the file (It asks whether or not the file exists). 
This page file is located at C:\pagefile.sys on all NT-based versions of Windows 
(including <A title="Windows 2000" 
href="http://en.wikipedia.org/wiki/Windows_2000">Windows 2000</A> and <A 
title="Windows XP" href="http://en.wikipedia.org/wiki/Windows_XP">Windows 
XP</A>), though Windows may be configured to place additional pagefiles on other 
drives.</P>
<P><A title="Windows 95" href="http://en.wikipedia.org/wiki/Windows_95">Windows 
95</A> uses a similar file, except it is named WIN386.SWP, and the controls for 
it are located under Control Panel - System - Performance tab - Virtual Memory. 
Windows automatically sets the page file to start 1.5x physical memory, and 
expand up to 3x physical memory if necessary. If a user runs memory intensive 
applications on a low physical memory system, it is preferable to manually set 
these sizes to a value higher than default.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=9">edit</A>]</DIV>
<P><A id=Misconceptions_about_the_Windows_page_file 
name=Misconceptions_about_the_Windows_page_file></A></P>
<H3>Misconceptions about the Windows page file</H3>
<P>There are some common misconceptions about Windows page file expansion, in 
that a page file can become heavily "fragmented" and cause "performance issues". 
The common advice given to avoid this problem is to set a single page file size, 
and not allow Windows to resize the page file. This is problematic for a few 
reasons;</P>
<UL>
  <LI>If a Windows application requests more memory than is available from both 
  physical memory and the page file, and Windows cannot resize the page file to 
  fulfill this request, then the memory is not successfully allocated. Many 
  applications (and sometimes Windows itself) will crash (sometimes gracefully, 
  sometimes not) as a result of being unable to allocate more memory. 
  <LI>Concerns about "performance" are moot when a Windows system is using two 
  or three times its total physical memory. Performance concerns about a further 
  expanding pagefile are not going to be a user's primary concern at this time. 
  <LI>Concerns about "fragmentation" are not significant, when you consider how 
  and when the page file is used. Windows does not read from or write to the 
  page file in sequential order for long periods of time, so the performance 
  advantages of having a completely sequential page file is minimal at best. 
  Also, if a large number of pages need to be moved in or out of the page file, 
  chances are quite good that other hard-disk activity is taking place at the 
  same time, further reducing performance. </LI></UL>
<P>In short, a Windows system does not benefit from having a locked page file 
size. A larger "minimum" size will indeed help systems with little physical 
memory by reducing resizing of the page file by the OS. A large "maximum" will 
incur no performance penalty.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=10">edit</A>]</DIV>
<P><A id=Virtual_Memory_in_Linux name=Virtual_Memory_in_Linux></A></P>
<H2>Virtual Memory in Linux</H2>
<P>In <A title=Linux href="http://en.wikipedia.org/wiki/Linux">Linux</A> 
operating system, it is possible to use a whole partition of the HDD for virtual 
memory. Though it is still possible to use a file for swapping, it is 
recommended to use a separate partition, because this excludes chances of <A 
title=Fragmentation 
href="http://en.wikipedia.org/wiki/Fragmentation#Data_fragmentation">fragmentation</A>, 
which reduces the performance of swapping. A swap area is created using the 
command <B>mkswap <I>filename/device</I></B> , and may be turned on and off 
using the commands <B>swapon</B> and <B>swapoff</B>, respectively, accompanied 
by the name of the swap file or the swap partition.</P>
<P>In order to additionally increase performance of swapping, it is advisable to 
put the swap partition at the beginning of the HDD, because the transfer speed 
there is somewhat higher than at the end of the disk.</P>
<P>There were also some successful <A class="external text" 
title="http://hedera.linuxnews.pl/ news/2002/09/03/ long/1445.html" 
href="http://hedera.linuxnews.pl/_news/2002/09/03/_long/1445.html">attempts</A> 
to use the memory located on the <A title="Video card" 
href="http://en.wikipedia.org/wiki/Video_card">videocard</A> for swapping, as 
modern videocards often have 128 or even 256 megabytes of RAM which normally 
only gets put to use when playing games.</P>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=11">edit</A>]</DIV>
<P><A id=See_also name=See_also></A></P>
<H2>See also</H2>
<UL>
  <LI><A title="CPU design" href="http://en.wikipedia.org/wiki/CPU_design">CPU 
  design</A> 
  <LI><A title=Computer 
  href="http://en.wikipedia.org/wiki/Computer">computer</A> 
  <LI><A title="Memory management" 
  href="http://en.wikipedia.org/wiki/Memory_management">memory management</A> 
  </LI></UL>
<P><BR></P>
<DIV class=boilerplate id=foldoc>
<DL>
  <DD><I>This article was originally based on material from the <A 
  title="Free On-line Dictionary of Computing" 
  href="http://en.wikipedia.org/wiki/Free_On-line_Dictionary_of_Computing">Free 
  On-line Dictionary of Computing</A>, which is <A 
  title="Wikipedia:Foldoc license" 
  href="http://en.wikipedia.org/wiki/Wikipedia:Foldoc_license">licensed</A> 
  under the <A title="GNU Free Documentation License" 
  href="http://en.wikipedia.org/wiki/GNU_Free_Documentation_License">GFDL</A>.</I> 
  </DD></DL></DIV>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=12">edit</A>]</DIV>
<P><A id=References name=References></A></P>
<H2>References</H2>
<UL>
  <LI>John L. Hennessy, David A. Patterson, <I>Computer Architecture, A 
  Quantitative Approach</I> (<A class=internal 
  href="http://en.wikipedia.org/w/index.php?title=Special:Booksources&amp;isbn=1558607242">ISBN 
  1-55860-724-2</A>) </LI></UL>
<DIV class=editsection style="FLOAT: right; MARGIN-LEFT: 5px">[<A 
title="Virtual memory" 
href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit&amp;section=13">edit</A>]</DIV>
<P><A id=External_links name=External_links></A></P>
<H2>External links</H2>
<UL>
  <LI><A class="external text" 
  title=http://computer.howstuffworks.com/virtual-memory.htm 
  href="http://computer.howstuffworks.com/virtual-memory.htm">How Virtual Memory 
  Works</A> 
  <LI><A class="external text" title=http://am.xs4all.nl/phpwiki/index.php/swap 
  href="http://am.xs4all.nl/phpwiki/index.php/swap">Linux swap partition</A> 
  <LI><A class="external text" title=http://linux-mm.org/ 
  href="http://linux-mm.org/">Linux Memory Management</A> 
  <LI><A class="external text" 
  title=http://www.pcnineoneone.com/howto/swpfile1.html 
  href="http://www.pcnineoneone.com/howto/swpfile1.html">Windows swap file 
  management</A> 
  <LI><A class="external text" 
  title="http://people.msoe.edu/~mccrawt/resume/papers/CS384/mccrawt cs384 virtual.pdf" 
  href="http://people.msoe.edu/~mccrawt/resume/papers/CS384/mccrawt_cs384_virtual.pdf">Virtual 
  Memory Page Replacement Algorithms</A> </LI></UL><!-- Saved in parser cache with key enwiki:pcache:idhash:32354-0!1!0!0!!en!2 and timestamp 20060117154500 -->
<DIV class=printfooter>Retrieved from "<A 
href="http://en.wikipedia.org/wiki/Virtual_memory">http://en.wikipedia.org/wiki/Virtual_memory</A>"</DIV>
<DIV id=catlinks>
<P class=catlinks><A title=Special:Categories 
href="http://en.wikipedia.org/w/index.php?title=Special:Categories&amp;article=Virtual_memory">Categories</A>: 
<SPAN dir=ltr><A title="Category:FOLDOC sourced articles" 
href="http://en.wikipedia.org/wiki/Category:FOLDOC_sourced_articles">FOLDOC 
sourced articles</A></SPAN> | <SPAN dir=ltr><A 
title="Category:Computer architecture" 
href="http://en.wikipedia.org/wiki/Category:Computer_architecture">Computer 
architecture</A></SPAN> | <SPAN dir=ltr><A title="Category:Virtual memory" 
href="http://en.wikipedia.org/wiki/Category:Virtual_memory">Virtual 
memory</A></SPAN></P></DIV><!-- end content -->
<DIV class=visualClear></DIV></DIV></DIV></DIV>
<DIV id=column-one>
<DIV class=portlet id=p-cactions>
<H5>Views</H5>
<UL>
  <LI class=selected id=ca-nstab-main><A 
  href="http://en.wikipedia.org/wiki/Virtual_memory">Article</A> 
  <LI id=ca-talk><A 
  href="http://en.wikipedia.org/wiki/Talk:Virtual_memory">Discussion</A> 
  <LI id=ca-edit><A 
  href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=edit">Edit 
  this page</A> 
  <LI id=ca-history><A 
  href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;action=history">History</A> 
  </LI></UL></DIV>
<DIV class=portlet id=p-personal>
<H5>Personal tools</H5>
<DIV class=pBody>
<UL>
  <LI id=pt-login><A 
  href="http://en.wikipedia.org/w/index.php?title=Special:Userlogin&amp;returnto=Virtual_memory">Sign 
  in / create account</A> </LI></UL></DIV></DIV>
<DIV class=portlet id=p-logo><A title="Main Page" 
style="BACKGROUND-IMAGE: url(/images/wiki-en.png)" 
href="http://en.wikipedia.org/wiki/Main_Page"></A></DIV>
<SCRIPT type=text/javascript> if (window.isMSIE55) fixalpha(); </SCRIPT>

<DIV class=portlet id=p-navigation>
<H5>Navigation</H5>
<DIV class=pBody>
<UL>
  <LI id=n-mainpage><A href="http://en.wikipedia.org/wiki/Main_Page">Main 
  Page</A> 
  <LI id=n-portal><A 
  href="http://en.wikipedia.org/wiki/Wikipedia:Community_Portal">Community 
  Portal</A> 
  <LI id=n-currentevents><A 
  href="http://en.wikipedia.org/wiki/Current_events">Current events</A> 
  <LI id=n-recentchanges><A 
  href="http://en.wikipedia.org/wiki/Special:Recentchanges">Recent changes</A> 
  <LI id=n-randompage><A 
  href="http://en.wikipedia.org/wiki/Special:Random">Random article</A> 
  <LI id=n-help><A href="http://en.wikipedia.org/wiki/Help:Contents">Help</A> 
  <LI id=n-contact><A 
  href="http://en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact us</A> 
  <LI id=n-sitesupport><A 
  href="http://wikimediafoundation.org/wiki/Fundraising#Donation_methods">Donations</A> 
  </LI></UL></DIV></DIV>
<DIV class=portlet id=p-search>
<H5><LABEL for=searchInput>Search</LABEL></H5>
<DIV class=pBody>
<FORM id=searchform action=/wiki/Special:Search>
<DIV><INPUT id=searchInput accessKey=f name=search> <INPUT class=searchButton id=searchGoButton type=submit value=Go name=go>&nbsp; <INPUT class=searchButton type=submit value=Search name=fulltext> 
</DIV></FORM></DIV></DIV>
<DIV class=portlet id=p-tb>
<H5>Toolbox</H5>
<DIV class=pBody>
<UL>
  <LI id=t-whatlinkshere><A 
  href="http://en.wikipedia.org/wiki/Special:Whatlinkshere/Virtual_memory">What 
  links here</A> 
  <LI id=t-recentchangeslinked><A 
  href="http://en.wikipedia.org/wiki/Special:Recentchangeslinked/Virtual_memory">Related 
  changes</A> 
  <LI id=t-upload><A href="http://en.wikipedia.org/wiki/Special:Upload">Upload 
  file</A> 
  <LI id=t-specialpages><A 
  href="http://en.wikipedia.org/wiki/Special:Specialpages">Special pages</A> 
  <LI id=t-print><A 
  href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;printable=yes">Printable 
  version</A> 
  <LI id=t-permalink><A 
  href="http://en.wikipedia.org/w/index.php?title=Virtual_memory&amp;oldid=34896676">Permanent 
  link</A>
  <LI id=t-cite><A 
  href="http://en.wikipedia.org/w/index.php?title=Special:Cite&amp;page=Virtual_memory&amp;id=34896676">Cite 
  this article</A> </LI></UL></DIV></DIV>
<DIV class=portlet id=p-lang>
<H5>In other languages</H5>
<DIV class=pBody>
<UL>
  <LI class=interwiki-cs><A 
  href="http://cs.wikipedia.org/wiki/VirtuÃ¡lnÃ&shy;_pamÄÅ¥">Česky</A> 
  <LI class=interwiki-da><A 
  href="http://da.wikipedia.org/wiki/Virtuel_hukommelse">Dansk</A> 
  <LI class=interwiki-de><A 
  href="http://de.wikipedia.org/wiki/Virtuelle_Speicherverwaltung">Deutsch</A> 
  <LI class=interwiki-es><A 
  href="http://es.wikipedia.org/wiki/Memoria_virtual">Español</A> 
  <LI class=interwiki-fr><A 
  href="http://fr.wikipedia.org/wiki/MÃ©moire_virtuelle">Français</A> 
  <LI class=interwiki-ko><A 
  href="http://ko.wikipedia.org/wiki/ê°ì_ë©ëª¨ë¦¬">한국어</A> 
  <LI class=interwiki-it><A 
  href="http://it.wikipedia.org/wiki/Memoria_virtuale">Italiano</A> 
  <LI class=interwiki-he><A 
  href="http://he.wikipedia.org/wiki/××××¨××_×××¨×××××">עברית</A> 
  <LI class=interwiki-lt><A 
  href="http://lt.wikipedia.org/wiki/Virtualioji_atmintis">Lietuvių</A> 
  <LI class=interwiki-nl><A 
  href="http://nl.wikipedia.org/wiki/Virtueel_geheugen">Nederlands</A> 
  <LI class=interwiki-ja><A 
  href="http://ja.wikipedia.org/wiki/ä»®æ³è¨æ¶">日本語</A> 
  <LI class=interwiki-pl><A 
  href="http://pl.wikipedia.org/wiki/PamiÄÄ_wirtualna">Polski</A> 
  <LI class=interwiki-pt><A 
  href="http://pt.wikipedia.org/wiki/MemÃ³ria_virtual">Português</A> 
  <LI class=interwiki-ru><A 
  href="http://ru.wikipedia.org/wiki/Ð¤Ð°Ð¹Ð»_Ð¿Ð¾Ð´ÐºÐ°ÑÐºÐ¸">Русский</A> 
  <LI class=interwiki-sl><A 
  href="http://sl.wikipedia.org/wiki/navidezni_pomnilnik">Slovenščina</A> 
  <LI class=interwiki-fi><A 
  href="http://fi.wikipedia.org/wiki/NÃ¤ennÃ¤ismuisti">Suomi</A> 
  <LI class=interwiki-sv><A 
  href="http://sv.wikipedia.org/wiki/Virtuellt_minne">Svenska</A> 
  <LI class=interwiki-zh><A 
  href="http://zh.wikipedia.org/wiki/èæåå&shy;">中文</A> 
</LI></UL></DIV></DIV></DIV><!-- end of the left (by default at least) column -->
<DIV class=visualClear></DIV>
<DIV id=footer>
<DIV id=f-poweredbyico><A href="http://www.mediawiki.org/"><IMG alt=MediaWiki 
src="Virtual memory - Wikipedia, the free encyclopedia_files/poweredby_mediawiki_88x31.png"></A></DIV>
<DIV id=f-copyrightico><A href="http://wikimediafoundation.org/"><IMG 
alt="Wikimedia Foundation" 
src="Virtual memory - Wikipedia, the free encyclopedia_files/wikimedia-button.png" 
border=0></A></DIV>
<UL id=f-list>
  <LI id=lastmod>This page was last modified 15:46, 12 January 2006. 
  <LI id=copyright>All text is available under the terms of the <A 
  class=internal 
  href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License">GNU 
  Free Documentation License</A> (see <B><A class=internal 
  href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights">Copyrights</A></B> 
  for details). <BR>Wikipedia® is a registered trademark of the Wikimedia 
  Foundation, Inc.<BR>
  <LI id=privacy><A title="wikimedia:Privacy policy" 
  href="http://wikimediafoundation.org/wiki/Privacy_policy">Privacy policy</A> 
  <LI id=about><A title=Wikipedia:About 
  href="http://en.wikipedia.org/wiki/Wikipedia:About">About Wikipedia</A> 
  <LI id=disclaimer><A title="Wikipedia:General disclaimer" 
  href="http://en.wikipedia.org/wiki/Wikipedia:General_disclaimer">Disclaimers</A> 
  </LI></UL></DIV>
<SCRIPT 
type=text/javascript> if (window.runOnloadHook) runOnloadHook();</SCRIPT>
</DIV><!-- Served by srv66 in 0.07 secs. --></BODY></HTML>
