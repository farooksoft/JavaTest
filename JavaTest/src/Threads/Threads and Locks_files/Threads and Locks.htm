<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0070)http://java.sun.com/docs/books/jls/second_edition/html/memory.doc.html -->
<HTML><HEAD><TITLE>Threads and Locks</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content=noindex,nofollow name=robots>
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#000077 aLink=#ff0000 link=#0000ff bgColor=#eeeeff>
<TABLE width="100%" border=0>
  <TBODY>
  <TR>
    <TD><A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jTOC.doc.html">Contents</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/defAssign.doc.html">Prev</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html">Next</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jIX.fm.html">Index</A></TD>
    <TD align=right><I>Java Language Specification</I><BR><FONT size=-1>Second 
      Edition</FONT></TD></TR></TBODY></TABLE>
<HR>
<BR><A name=26250></A>
<P><STRONG>CHAPTER 17 </STRONG></P><A name=30206></A>
<H1>Threads and Locks</H1>
<HR>

<P><A name=44127></A>While most of the discussion in the preceding chapters is 
concerned only with the behavior of code as executed a single statement or 
expression at a time, that is, by a single <EM>thread</EM>, each Java virtual 
machine can support many threads of execution at once. These threads 
independently execute code that operates on values and objects residing in a 
shared main memory. Threads may be supported by having many hardware processors, 
by time-slicing a single hardware processor, or by time-slicing many hardware 
processors.
<P><A name=28270></A>The Java programming language supports the coding of 
programs that, though concurrent, still exhibit deterministic behavior, by 
providing mechanisms for <EM>synchronizing</EM> the concurrent activity of 
threads. To synchronize threads, the Java programming language uses 
<EM>monitors</EM>, which are a high-level mechanism for allowing only one thread 
at a time to execute a region of code protected by the monitor. The behavior of 
monitors is explained in terms of <EM>locks</EM>; there is a lock associated 
with each object.
<P><A name=29608></A>The <CODE>synchronized</CODE> statement <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/statements.doc.html#255769">(§14.18)</A> 
performs two special actions relevant only to multithreaded operation: (1) after 
computing a reference to an object but before executing its body, it 
<EM>locks</EM> a lock associated with the object, and (2) after execution of the 
body has completed, either normally or abruptly, it <EM>unlocks</EM> that same 
lock. As a convenience, a method may be declared <CODE>synchronized</CODE>; such 
a method behaves as if its body were contained in a <CODE>synchronized</CODE> 
statement.
<P><A name=29615></A>The methods <CODE>wait</CODE>, <CODE>notify</CODE>, and 
<CODE>notifyAll</CODE> of class <CODE>Object</CODE> support an efficient 
transfer of control from one thread to another. Rather than simply "spinning" 
(repeatedly locking and unlocking an object to see whether some internal state 
has changed), which consumes computational effort, a thread can suspend itself 
using <CODE>wait</CODE> until such time as another thread awakens it using 
<CODE>notify</CODE>. This is especially appropriate in situations where threads 
have a producer-consumer relationship (actively cooperating on a common goal) 
rather than a mutual exclusion relationship (trying to avoid conflicts while 
sharing a common resource).
<P><A name=28284></A>As a thread executes code, it carries out a sequence of 
actions. A thread may <EM>use</EM> the value of a variable or <EM>assign</EM> it 
a new value. (Other actions include arithmetic operations, conditional tests, 
and method invocations, but these do not involve variables directly.) If two or 
more concurrent threads act on a shared variable, there is a possibility that 
the actions on the variable will produce timing-dependent results. This 
dependence on timing is inherent in concurrent programming, producing one of the 
few places in the language where the result of executing a program is not 
determined solely by this specification.
<P><A name=28285></A>Each thread has a working memory, in which it may keep 
copies of the values of variables from the main memory that is shared between 
all threads. To access a shared variable, a thread usually first obtains a lock 
and flushes its working memory. This guarantees that shared values will 
thereafter be loaded from the shared main memory to the threads working memory. 
When a thread unlocks a lock it guarantees the values it holds in its working 
memory will be written back to the main memory.
<P><A name=28524></A>This chapter explains the interaction of threads with the 
main memory, and thus with each other, in terms of certain low-level actions. 
There are rules about the order in which these actions may occur. These rules 
impose constraints on any implementation of the Java programming language, and a 
programmer may rely on the rules to predict the possible behaviors of a 
concurrent program. The rules do, however, intentionally give the implementor 
certain freedoms; the intent is to permit certain standard hardware and software 
techniques that can greatly improve the speed and efficiency of concurrent code.
<P><A name=28527></A>Briefly put, these are the important consequences of the 
rules:
<P>
<UL><A name=28549></A>
  <LI>Proper use of synchronization constructs will allow reliable transmission 
  of values or sets of values from one thread to another through shared 
  variables. <A name=28553></A>
  <LI>When a thread uses the value of a variable, the value it obtains is in 
  fact a value stored into the variable by that thread or by some other thread. 
  This is true even if the program does not contain code for proper 
  synchronization. For example, if two threads store references to different 
  objects into the same reference value, the variable will subsequently contain 
  a reference to one object or the other, not a reference to some other object 
  or a corrupted reference value. (There is a special exception for 
  <CODE>long</CODE> and <CODE>double</CODE> values; see <A 
  href="http://java.sun.com/docs/books/jls/second_edition/html/memory.doc.html#28733">§17.4</A>.) 
  <A name=28556></A>
  <LI>In the absence of explicit synchronization, an implementation is free to 
  update the main memory in an order that may be surprising. Therefore the 
  programmer who prefers to avoid surprises should use explicit synchronization. 
  </LI></UL><A name=28287></A>
<H2>17.1 Terminology and Framework</H2><A name=28288></A>A <EM>variable</EM> is 
any location within a program that may be stored into. This includes not only 
class variables and instance variables but also components of arrays. Variables 
are kept in a <EM>main memory</EM> that is shared by all threads. Because it is 
impossible for one thread to access parameters or local variables of another 
thread, it doesn't matter whether parameters and local variables are thought of 
as residing in the shared main memory or in the working memory of the thread 
that owns them.
<P><A name=45672></A>Every thread has a <EM>working memory</EM> in which it 
keeps its own <EM>working copy</EM> of variables that it must use or assign. As 
the thread executes a program, it operates on these working copies. The main 
memory contains the <EM>master copy</EM> of every variable. There are rules 
about when a thread is permitted or required to transfer the contents of its 
working copy of a variable into the master copy or vice versa.
<P><A name=28291></A>The main memory also contains <EM>locks</EM>; there is one 
lock associated with each object. Threads may compete to acquire a lock.
<P><A name=28292></A>For the purposes of this chapter, the verbs <EM>use</EM>, 
<EM>assign</EM>, <EM>load</EM>, <EM>store</EM>, <EM>lock</EM>, and 
<EM>unlock</EM> name <EM>actions</EM> that a thread can perform. The verbs 
<EM>read</EM>, <EM>write</EM>, <EM>lock</EM>, and <EM>unlock</EM> name actions 
that the main memory subsystem can perform. Each of these actions is 
<EM>atomic</EM> (indivisible). 
<P><A name=28293></A>A <EM>use</EM> or <EM>assign</EM> action is a tightly 
coupled interaction between a thread's execution engine and the thread's working 
memory. A <EM>lock</EM> or <EM>unlock</EM> action is a tightly coupled 
interaction between a thread's execution engine and the main memory. But the 
transfer of data between the main memory and a thread's working memory is 
loosely coupled. When data is copied from the main memory to a working memory, 
two actions must occur: a <EM>read</EM> action performed by the main memory 
followed some time later by a corresponding <EM>load</EM> action performed by 
the working memory. When data is copied from a working memory to the main 
memory, two actions must occur: a <EM>store</EM> action performed by the working 
memory followed some time later by a corresponding <EM>write</EM> action 
performed by the main memory. There may be some transit time between main memory 
and a working memory, and the transit time may be different for each 
transaction; thus actions initiated by a thread on different variables may 
viewed by another thread as occurring in a different order. For each variable, 
however, the actions in main memory on behalf of any one thread are performed in 
the same order as the corresponding actions by that thread. (This is explained 
in greater detail below.)
<P><A name=28294></A>A single thread issues a stream of <EM>use</EM>, 
<EM>assign</EM>, <EM>lock</EM>, and <EM>unlock</EM> actions as dictated by the 
semantics of the program it is executing. The underlying implementation is then 
required additionally to perform appropriate <EM>load</EM>, <EM>store</EM>, 
<EM>read</EM>, and <EM>write</EM> actions so as to obey a certain set of 
constraints, explained below. If the implementation correctly follows these 
rules and the application programmer follows certain other rules of programming, 
then data can be reliably transferred between threads through shared variables. 
The rules are designed to be "tight" enough to make this possible but "loose" 
enough to allow hardware and software designers considerable freedom to improve 
speed and throughput through such mechanisms as registers, queues, and caches.
<P><A name=28295></A>Here are the detailed definitions of each of the actions:
<P>
<UL><A name=28296></A>
  <LI>A <EM>use</EM> action (by a thread) transfers the contents of the thread's 
  working copy of a variable to the thread's execution engine. This action is 
  performed whenever a thread executes a virtual machine instruction that uses 
  the value of a variable. <A name=28297></A>
  <LI>An <EM>assign</EM> action (by a thread) transfers a value from the 
  thread's execution engine into the thread's working copy of a variable. This 
  action is performed whenever a thread executes a virtual machine instruction 
  that assigns to a variable. <A name=28298></A>
  <LI>A <EM>read</EM> action (by the main memory) transmits the contents of the 
  master copy of a variable to a thread's working memory for use by a later 
  <EM>load</EM> action. <A name=28299></A>
  <LI>A <EM>load </EM>action (by a thread) puts a value transmitted from main 
  memory by a <EM>read</EM> action into the thread's working copy of a variable. 
  <A name=28300></A>
  <LI>A <EM>store </EM>action (by a thread) transmits the contents of the 
  thread's working copy of a variable to main memory for use by a later 
  <EM>write</EM> action. <A name=28301></A>
  <LI>A <EM>write</EM> action (by the main memory) puts a value transmitted from 
  the thread's working memory by a <EM>store</EM> action into the master copy of 
  a variable in main memory. <A name=28303></A>
  <LI>A <EM>lock</EM> action (by a thread tightly synchronized with main memory) 
  causes a thread to acquire one claim on a particular lock. <A name=28304></A>
  <LI>An <EM>unlock</EM> action (by a thread tightly synchronized with main 
  memory) causes a thread to release one claim on a particular lock. </LI></UL><A 
name=28305></A>Thus the interaction of a thread with a variable over time 
consists of a sequence of <EM>use</EM>, <EM>assign</EM>, <EM>load</EM>, and 
<EM>store</EM> actions. Main memory performs a <EM>read</EM> action for every 
<EM>load</EM> and a <EM>write</EM> action for every <EM>store</EM>. A thread's 
interactions with a lock over time consists of a sequence of <EM>lock</EM> and 
<EM>unlock</EM> actions. All the globally visible behavior of a thread thus 
comprises all the thread's actions on variables and locks.
<P><A name=28920></A>
<H2>17.2 Execution Order</H2><A name=28957></A>The rules of execution order 
constrain the order in which certain events may occur. There are four general 
constraints on the relationships among actions:
<P>
<UL><A name=28958></A>
  <LI>The actions performed by any one thread are totally ordered; that is, for 
  any two actions performed by a thread, one action precedes the other. <A 
  name=28976></A>
  <LI>The actions performed by the main memory for any one variable are totally 
  ordered; that is, for any two actions performed by the main memory on the same 
  variable, one action precedes the other. <A name=28980></A>
  <LI>The actions performed by the main memory for any one lock are totally 
  ordered; that is, for any two actions performed by the main memory on the same 
  lock, one action precedes the other. <A name=28959></A>
  <LI>It is not permitted for an action to follow itself. </LI></UL><A 
name=28990></A>The last rule may seem trivial, but it does need to be stated 
separately and explicitly for completeness. Without it, it would be possible to 
propose a set of actions by two or more threads and precedence relationships 
among the actions that would satisfy all the other rules but would require an 
action to follow itself.
<P><A name=28951></A>Threads do not interact directly; they communicate only 
through the shared main memory. The relationships between the actions of a 
thread and the actions of main memory are constrained in three ways: 
<P>
<UL><A name=28923></A>
  <LI>Each <EM>lock</EM> or <EM>unlock</EM> action is performed jointly by some 
  thread and the main memory. <A name=28924></A>
  <LI>Each <EM>load</EM> action by a thread is uniquely paired with a 
  <EM>read</EM> action by the main memory such that the <EM>load</EM> action 
  follows the <EM>read</EM> action. <A name=28925></A>
  <LI>Each <EM>store</EM> action by a thread is uniquely paired with a 
  <EM>write</EM> action by the main memory such that the <EM>write</EM> action 
  follows the <EM>store</EM> action. </LI></UL><A name=45036></A>Most of the rules 
in the following sections further constrain the order in which certain actions 
take place. A rule may state that one action must precede or follow some other 
action. Note that this relationship is transitive: if action <I>A</I> must 
precede action <I>B</I>, and <I>B</I> must precede <I>C</I>, then <I>A</I> must 
precede <I>C</I>. The programmer must remember that these rules are the 
<EM>only</EM> constraints on the ordering of actions; if no rule or combination 
of rules implies that action <I>A</I> must precede action <I>B</I>, then an 
implementation is free to perform action <I>B</I> before action <I>A</I>, or to 
perform action <I>B</I> concurrently with action <I>A</I>. This freedom can be 
the key to good performance. Conversely, an implementation is not required to 
take advantage of all the freedoms given it.
<P><A name=28927></A>In the rules that follow, the phrasing "<I>B</I> must 
intervene between <I>A</I> and <I>C</I>" means that action <I>B</I> must follow 
action <I>A</I> and precede action <I>C</I>.
<P><A name=28654></A>
<H2>17.3 Rules about Variables</H2><A name=28308></A>Let <I>T</I> be a thread 
and <I>V</I> be a variable. There are certain constraints on the actions 
performed by <I>T</I> with respect to <I>V</I>:
<P>
<UL><A name=28309></A>
  <LI>An <EM>use</EM> or <EM>assign</EM> by <I>T</I> of <I>V</I> is permitted 
  only when dictated by execution by <I>T</I> of the program according to the 
  Java programming language's execution model. For example, an occurrence of 
  <I>V</I> as an operand of the <CODE>+</CODE> operator requires that a single 
  <EM>use</EM> action occur on <I>V</I>; an occurrence of <I>V</I> as the 
  left-hand operand of the assignment operator <CODE>=</CODE> requires that a 
  single <EM>assign</EM> action occur. All <EM>use</EM> and <EM>assign</EM> 
  actions by a given thread must occur in the order specified by the program 
  being executed by the thread. If the following rules forbid <I>T</I> to 
  perform a required <EM>use</EM> as its next action, it may be necessary for 
  <I>T</I> to perform a <EM>load </EM>first in order to make progress. <A 
  name=28310></A>
  <LI>A <EM>store</EM> action by <I>T</I> on <I>V</I> must intervene between an 
  <EM>assign</EM> by <I>T</I> of <I>V</I> and a subsequent <EM>load</EM> by 
  <I>T</I> of <I>V</I>. (Less formally: a thread is not permitted to lose its 
  most recent assign.) <A name=28312></A>
  <LI>An <EM>assign</EM> action by <I>T</I> on <I>V</I> must intervene between a 
  <EM>load</EM> or <EM>store</EM> by <I>T</I> of <I>V</I> and a subsequent 
  <EM>store</EM> by <I>T</I> of <I>V</I>. (Less formally: a thread is not 
  permitted to write data from its working memory back to main memory for no 
  reason.) <A name=28313></A>
  <LI>After a thread is created, it must perform an <EM>assign</EM> or 
  <EM>load</EM> action on a variable before performing a <EM>use</EM> or 
  <EM>store</EM> action on that variable. (Less formally: a new thread starts 
  with an empty working memory.) <A name=28314></A>
  <LI>After a variable is created, every thread must perform an <EM>assign</EM> 
  or <EM>load</EM> action on that variable before performing a <EM>use</EM> or 
  <EM>store</EM> action on that variable. (Less formally: a new variable is 
  created only in main memory and is not initially in any thread's working 
  memory.) </LI></UL><A name=28315></A>Provided that all the constraints above and 
below are obeyed, a <EM>load</EM> or <EM>store</EM> action may be issued at any 
time by any thread on any variable, at the whim of the implementation.
<P><A name=28317></A>There are also certain constraints on the <EM>read</EM> and 
<EM>write</EM> actions performed by main memory:
<P>
<UL><A name=28318></A>
  <LI>For every <EM>load</EM> action performed by any thread <I>T</I> on its 
  working copy of a variable <I>V</I>, there must be a corresponding preceding 
  <EM>read</EM> action by the main memory on the master copy of <I>V</I>, and 
  the <EM>load</EM> action must put into the working copy the data transmitted 
  by the corresponding <EM>read</EM> action. <A name=28319></A>
  <LI>For every <EM>store</EM> action performed by any thread <I>T</I> on its 
  working copy of a variable <I>V</I>, there must be a corresponding following 
  <EM>write</EM> action by the main memory on the master copy of <I>V</I>, and 
  the <EM>write</EM> action must put into the master copy the data transmitted 
  by the corresponding <EM>store</EM> action. <A name=28786></A>
  <LI>Let action <I>A</I> be a <EM>load</EM> or <EM>store</EM> by thread 
  <I>T</I> on variable <I>V</I>, and let action <I>P</I> be the corresponding 
  <EM>read</EM> or <EM>write</EM> by the main memory on variable <I>V</I>. 
  Similarly, let action <I>B</I> be some other <EM>load</EM> or <EM>store</EM> 
  by thread <I>T</I> on that same variable <I>V</I>, and let action <I>Q</I> be 
  the corresponding <EM>read</EM> or <EM>write</EM> by the main memory on 
  variable <I>V</I>. If <I>A</I> precedes <I>B</I>, then <I>P</I> must precede 
  <I>Q</I>. (Less formally: actions on the master copy of any given variable on 
  behalf of a thread are performed by the main memory in exactly the order that 
  the thread requested.) </LI></UL><A name=28817></A>Note that this last rule 
applies <EM>only</EM> to actions by a thread on the <EM>same</EM> variable. 
However, there is a more stringent rule for <CODE>volatile</CODE> variables <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/memory.doc.html#28330">(§17.7)</A>.
<P><A name=28733></A>
<H2>17.4 Nonatomic Treatment of double and long</H2><A name=55837></A>If a 
<CODE>double</CODE> or <CODE>long</CODE> variable is not declared 
<CODE>volatile</CODE>, then for the purposes of <EM>load</EM>, <EM>store</EM>, 
<EM>read</EM>, and <EM>write</EM> actions they are treated as if they were two 
variables of 32 bits each: wherever the rules require one of these actions, two 
such actions are performed, one for each 32-bit half. The manner in which the 64 
bits of a <CODE>double</CODE> or <CODE>long</CODE> variable are encoded into two 
32-bit quantities is implementation-dependent. The <EM>load</EM>, 
<EM>store</EM>, <EM>read</EM>, and <EM>write</EM> actions on 
<CODE>volatile</CODE> variables are atomic, even if the type of the variable is 
<CODE>double</CODE> or <CODE>long</CODE>.
<P><A name=28747></A>This matters only because a <EM>read</EM> or <EM>write</EM> 
of a <CODE>double</CODE> or <CODE>long</CODE> variable may be handled by an 
actual main memory as two 32-bit <EM>read</EM> or <EM>write</EM> actions that 
may be separated in time, with other actions coming between them. Consequently, 
if two threads concurrently assign distinct values to the same shared 
non-<CODE>volatile</CODE> <CODE>double</CODE> or <CODE>long</CODE> variable, a 
subsequent use of that variable may obtain a value that is not equal to either 
of the assigned values, but some implementation-dependent mixture of the two 
values.
<P><A name=28746></A>An implementation is free to implement <EM>load</EM>, 
<EM>store</EM>, <EM>read</EM>, and <EM>write</EM> actions for 
<CODE>double</CODE> and <CODE>long</CODE> values as atomic 64-bit actions; in 
fact, this is strongly encouraged. The model divides them into 32-bit halves for 
the sake of several currently popular microprocessors that fail to provide 
efficient atomic memory transactions on 64-bit quantities. It would have been 
simpler to define all memory transactions on single variables as atomic; this 
more complex definition is a pragmatic concession to current hardware practice. 
In the future this concession may be eliminated. Meanwhile, programmers are 
cautioned always to explicitly synchronize access to shared <CODE>double</CODE> 
and <CODE>long</CODE> variables.
<P><A name=28320></A>
<H2>17.5 Rules about Locks</H2><A name=28321></A>Let <I>T</I> be a thread and 
<I>L</I> be a lock. There are certain constraints on the actions performed by 
<I>T</I> with respect to <I>L</I>:
<P>
<UL><A name=28322></A>
  <LI>A <EM>lock</EM> action by <I>T</I> on <I>L</I> may occur only if, for 
  every thread <I>S</I> other than <I>T</I>, the number of preceding 
  <EM>unlock</EM> actions by <I>S</I> on <I>L</I> equals the number of preceding 
  <EM>lock</EM> actions by <I>S</I> on <I>L</I>. (Less formally: only one thread 
  at a time is permitted to lay claim to a lock, and moreover a thread may 
  acquire the same lock multiple times and doesn't relinquish ownership of it 
  until a matching number of <EM>unlock</EM> actions have been performed.) <A 
  name=28763></A>
  <LI>An <EM>unlock</EM> action by thread <I>T</I> on lock <I>L</I> may occur 
  only if the number of preceding <EM>unlock</EM> actions by <I>T</I> on 
  <I>L</I> is strictly less than the number of preceding <EM>lock</EM> actions 
  by <I>T</I> on <I>L</I>. (Less formally: a thread is not permitted to unlock a 
  lock it doesn't own.) </LI></UL><A name=28324></A>With respect to a lock, the 
<EM>lock</EM> and <EM>unlock</EM> actions performed by all the threads are 
performed in some total sequential order. This total order must be consistent 
with the total order on the actions of each thread.
<P><A name=28325></A>
<H2>17.6 Rules about the Interaction of Locks and Variables</H2><A 
name=28326></A>Let <I>T</I> be any thread, let <I>V</I> be any variable, and let 
<I>L</I> be any lock. There are certain constraints on the actions performed by 
<I>T</I> with respect to <I>V</I> and <I>L</I>:
<P>
<UL><A name=28327></A>
  <LI>Between an <EM>assign</EM> action by <I>T</I> on <I>V</I> and a subsequent 
  <EM>unlock</EM> action by <I>T</I> on <I>L</I>, a <EM>store</EM> action by 
  <I>T</I> on <I>V</I> must intervene; moreover, the <EM>write</EM> action 
  corresponding to that <EM>store</EM> must precede the <EM>unlock</EM> action, 
  as seen by main memory. (Less formally: if a thread is to perform an 
  <EM>unlock</EM> action on <EM>any</EM> lock, it must first copy <EM>all</EM> 
  assigned values in its working memory back out to main memory.) <A 
  name=28328></A>
  <LI>Between a <EM>lock</EM> action by <I>T</I> on <I>L</I> and a subsequent 
  <EM>use</EM> or <EM>store</EM> action by <I>T</I> on a variable <I>V</I>, an 
  <EM>assign</EM> or <EM>load</EM> action on <I>V</I> must intervene; moreover, 
  if it is a <EM>load</EM> action, then the <EM>read</EM> action corresponding 
  to that <EM>load</EM> must follow the <EM>lock</EM> action, as seen by main 
  memory. (Less formally: a <EM>lock</EM> action acts as if it flushes 
  <EM>all</EM> variables from the thread's working memory; before use they must 
  be assigned or loaded from main memory.) </LI></UL><A name=28330></A>
<H2>17.7 Rules for Volatile Variables</H2><A name=28331></A>If a variable is 
declared <CODE>volatile</CODE>, then additional constraints apply to the actions 
of each thread. 
<P><A name=55958></A>Let <I>T</I> be a thread and let <I>V</I> and <I>W</I> be 
volatile variables.
<P>
<UL><A name=28332></A>
  <LI>A <EM>use</EM> action by <I>T</I> on <I>V</I> is permitted only if the 
  previous action by <I>T</I> on <I>V</I> was <EM>load</EM>, and a <EM>load</EM> 
  action by <I>T</I> on <I>V</I> is permitted only if the next action by 
  <I>T</I> on <I>V</I> is <EM>use</EM>. The <EM>use</EM> action is said to be 
  "associated" with the <EM>read</EM> action that corresponds to the 
  <EM>load</EM>. <A name=28333></A>
  <LI>A <EM>store</EM> action by <I>T</I> on <I>V</I> is permitted only if the 
  previous action by <I>T</I> on <I>V</I> was <EM>assign</EM>, and an 
  <EM>assign</EM> action by <I>T</I> on <I>V</I><I></I> is permitted only if the 
  next action by <I>T</I> on <I>V</I> is <EM>store</EM>. The <EM>assign</EM> 
  action is said to be "associated" with the <EM>write</EM> action that 
  corresponds to the <EM>store</EM>. <A name=45390></A>
  <LI>Let action <I>A</I> be a <EM>use</EM> or <EM>assign</EM> by thread 
  <I>T</I> on variable <I>V</I>, let action <I>F</I> be the <EM>load</EM> or 
  <EM>store</EM> associated with <I>A</I>, and let action <I>P</I> be the 
  <EM>read</EM> or <EM>write</EM> of <I>V</I> that corresponds to <I>F</I>. 
  Similarly, let action <I>B</I> be a <EM>use</EM> or <EM>assign</EM> by thread 
  <I>T</I> on variable <I>W</I>, let action <I>G</I> be the <EM>load</EM> or 
  <EM>store</EM> associated with <I>B</I>, and let action <I>Q</I> be the 
  <EM>read</EM> or <EM>write</EM> of <I>W</I> that corresponds to <I>G</I>. If 
  <I>A</I> precedes <I>B</I>, then <I>P</I> must precede <I>Q</I>. (Less 
  formally: actions on the master copies of volatile variables on behalf of a 
  thread are performed by the main memory in exactly the order that the thread 
  requested.) </LI></UL><A name=55816></A>The <EM>load</EM>, <EM>store</EM>, 
<EM>read</EM>, and <EM>write</EM> actions on <CODE>volatile</CODE> variables are 
atomic, even if the type of the variable is <CODE>double</CODE> or 
<CODE>long</CODE>.
<P><A name=45376></A>
<H2>17.8 Prescient Store Actions</H2><A name=45377></A>If a variable is not 
declared <CODE>volatile</CODE>, then the rules in the previous sections are 
relaxed slightly to allow <EM>store</EM> actions to occur earlier than would 
otherwise be permitted. The purpose of this relaxation is to allow optimizing 
Java compilers to perform certain kinds of code rearrangement that preserve the 
semantics of properly synchronized programs but might be caught in the act of 
performing memory actions out of order by programs that are not properly 
synchronized.
<P><A name=45378></A>Suppose that a <EM>store</EM> by <I>T</I> of <I>V</I> would 
follow a particular <EM>assign</EM> by <I>T</I> of <I>V</I> according to the 
rules of the previous sections, with no intervening <EM>load</EM> or 
<EM>assign</EM> by <I>T</I> of <I>V</I>. Then that <EM>store</EM> action would 
send to the main memory the value that the <EM>assign</EM> action put into the 
working memory of thread <I>T</I>. The special rule allows the <EM>store</EM> 
action to instead occur before the <EM>assign</EM> action, if the following 
restrictions are obeyed:
<P>
<UL><A name=45379></A>
  <LI>If the <EM>store</EM> action occurs, the <EM>assign</EM> is bound to 
  occur. (Remember, these are restrictions on what actually happens, not on what 
  a thread plans to do. No fair performing a <EM>store</EM> and then throwing an 
  exception before the <EM>assign</EM> occurs!) <A name=45380></A>
  <LI>No <EM>lock</EM> action intervenes between the relocated <EM>store</EM> 
  and the <EM>assign</EM>. <A name=45381></A>
  <LI>No <EM>load</EM> of <I>V</I> intervenes between the relocated 
  <EM>store</EM> and the <EM>assign</EM>. <A name=45382></A>
  <LI>No other <EM>store</EM> of <I>V</I> intervenes between the relocated 
  <EM>store</EM> and the <EM>assign</EM>. <A name=45383></A>
  <LI>The <EM>store</EM> action sends to the main memory the value that the 
  <EM>assign</EM> action will put into the working memory of thread <I>T</I>. 
  </LI></UL><A name=45384></A>This last property inspires us to call such an early 
<EM>store</EM> action <EM>prescient</EM>: it has to know ahead of time, somehow, 
what value will be stored by the <EM>assign</EM> that it should have followed. 
In practice, optimized compiled code will compute such values early (which is 
permitted if, for example, the computation has no side effects and throws no 
exceptions), store them early (before entering a loop, for example), and keep 
them in working registers for later use within the loop.
<P><A name=28341></A>
<H2>17.9 Discussion</H2><A name=28342></A>Any association between locks and 
variables is purely conventional. Locking any lock conceptually flushes 
<EM>all</EM> variables from a thread's working memory, and unlocking any lock 
forces the writing out to main memory of <EM>all</EM> variables that the thread 
has assigned. That a lock may be associated with a particular object or a class 
is purely a convention. In some applications, it may be appropriate always to 
lock an object before accessing any of its instance variables, for example; 
synchronized methods are a convenient way to follow this convention. In other 
applications, it may suffice to use a single lock to synchronize access to a 
large collection of objects.
<P><A name=28343></A>If a thread uses a particular shared variable only after 
locking a particular lock and before the corresponding unlocking of that same 
lock, then the thread will read the shared value of that variable from main 
memory after the <EM>lock</EM> action, if necessary, and will copy back to main 
memory the value most recently assigned to that variable before the 
<EM>unlock</EM> action. This, in conjunction with the mutual exclusion rules for 
locks, suffices to guarantee that values are correctly transmitted from one 
thread to another through shared variables.
<P><A name=28344></A>The rules for <CODE>volatile</CODE> variables effectively 
require that main memory be touched exactly once for each <EM>use</EM> or 
<EM>assign</EM> of a <CODE>volatile</CODE> variable by a thread, and that main 
memory be touched in exactly the order dictated by the thread execution 
semantics. However, such memory actions are not ordered with respect to 
<EM>read</EM> and <EM>write</EM> actions on nonvolatile variables.
<P><A name=28345></A>
<H2>17.10 Example: Possible Swap</H2><A name=28346></A>Consider a class that has 
class variables <CODE>a</CODE> and <CODE>b</CODE> and methods 
<CODE>hither</CODE> and <CODE>yon</CODE>:
<P>
<BLOCKQUOTE><PRE>class Sample {
	int a = 1, b = 2;
	void hither() {
		a = b;
	}
	void yon() {
		b = a;
	}
}
</PRE></BLOCKQUOTE><A name=28356></A>Now suppose that two threads are created, 
and that one thread calls <CODE>hither</CODE> while the other thread calls 
<CODE>yon</CODE>. What is the required set of actions and what are the ordering 
constraints?
<P><A name=28357></A>Let us consider the thread that calls <CODE>hither</CODE>. 
According to the rules, this thread must perform an <EM>use</EM> of 
<CODE>b</CODE> followed by an <EM>assign</EM> of <CODE>a</CODE>. That is the 
bare minimum required to execute a call to the method <CODE>hither</CODE>.
<P><A name=28358></A>Now, the first action on variable <CODE>b</CODE> by the 
thread cannot be <EM>use</EM>. But it may be <EM>assign</EM> or <EM>load</EM>. 
An <EM>assign</EM> to <CODE>b</CODE> cannot occur because the program text does 
not call for such an <EM>assign</EM> action, so a <EM>load</EM> of 
<CODE>b</CODE> is required. This <EM>load</EM> action by the thread in turn 
requires a preceding <EM>read</EM> action for <CODE>b</CODE> by the main memory.
<P><A name=28359></A>The thread may optionally <EM>store</EM> the value of 
<CODE>a</CODE> after the <EM>assign</EM> has occurred. If it does, then the 
<EM>store</EM> action in turn requires a following <EM>write</EM> action for 
<CODE>a</CODE> by the main memory.
<P><A name=28360></A>The situation for the thread that calls <CODE>yon</CODE> is 
similar, but with the roles of <CODE>a</CODE> and <CODE>b</CODE> exchanged.
<P><A name=28388></A>The total set of actions may be pictured as follows:
<P>
<CENTER><IMG src="Threads and Locks_files/17.doc.anc.gif">
<P></CENTER><A name=29084></A>Here an arrow from action <EM>A</EM> to action 
<EM>B</EM> indicates that <EM>A</EM> must precede <EM>B</EM>.
<P><A name=28389></A>In what order may the actions by the main memory occur? The 
only constraint is that it is not possible both for the <EM>write</EM> of 
<CODE>a</CODE> to precede the <EM>read</EM> of <CODE>a</CODE> and for the 
<EM>write</EM> of <CODE>b</CODE> to precede the <EM>read</EM> of <CODE>b</CODE>, 
because the causality arrows in the diagram would form a loop so that an action 
would have to precede itself, which is not allowed. Assuming that the optional 
<EM>store</EM> and <EM>write</EM> actions are to occur, there are three possible 
orderings in which the main memory might legitimately perform its actions. Let 
<CODE>ha</CODE> and <CODE>hb</CODE> be the working copies of <CODE>a</CODE> and 
<CODE>b</CODE> for the <CODE>hither</CODE> thread, let <CODE>ya</CODE> and 
<CODE>yb</CODE> be the working copies for the <CODE>yon</CODE> thread, and let 
<CODE>ma</CODE> and <CODE>mb</CODE> be the master copies in main memory. 
Initially <CODE>ma=1</CODE> and <CODE>mb=2</CODE>. Then the three possible 
orderings of actions and the resulting states are as follows:
<P>
<UL><A name=28390></A>
  <LI><EM>write</EM> <CODE>a</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">read <CODE>a</CODE>, <EM>read</EM> 
  <CODE>b</CODE><IMG src="Threads and Locks_files/arrwrite.gif">write 
  <CODE>b</CODE> (then <CODE>ha=2</CODE>, <CODE>hb=2</CODE>, <CODE>ma=2</CODE>, 
  <CODE>mb=2</CODE>, <CODE>ya=2</CODE>, <CODE>yb=2</CODE>) <A name=29157></A>
  <LI><EM>read</EM> <CODE>a</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">write <CODE>a</CODE>, 
  <EM>write</EM> <CODE>b</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">read <CODE>b</CODE> (then 
  <CODE>ha=1</CODE>, <CODE>hb=1</CODE>, <CODE>ma=1</CODE>, <CODE>mb=1</CODE>, 
  <CODE>ya=1</CODE>, <CODE>yb=1</CODE>) <A name=28391></A>
  <LI><EM>read</EM> <CODE>a</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">write <CODE>a</CODE>, <EM>read</EM> 
  <CODE>b</CODE><IMG src="Threads and Locks_files/arrwrite.gif">write 
  <CODE>b</CODE> (then <CODE>ha=2</CODE>, <CODE>hb=2</CODE>, <CODE>ma=2</CODE>, 
  <CODE>mb=1</CODE>, <CODE>ya=1</CODE>, <CODE>yb=1</CODE>) </LI></UL><A 
name=29137></A>Thus the net result might be that, in main memory, <CODE>b</CODE> 
is copied into <CODE>a</CODE>, <CODE>a</CODE> is copied into <CODE>b</CODE>, or 
the values of <CODE>a</CODE> and <CODE>b</CODE> are swapped; moreover, the 
working copies of the variables might or might not agree. It would be incorrect, 
of course, to assume that any one of these outcomes is more likely than another. 
This is one place in which the behavior of a program is necessarily 
timing-dependent.
<P><A name=29184></A>Of course, an implementation might also choose not to 
perform the <EM>store</EM> and <EM>write</EM> actions, or only one of the two 
pairs, leading to yet other possible results.
<P><A name=29185></A>Now suppose that we modify the example to use 
<CODE>synchronized</CODE> methods:
<P>
<BLOCKQUOTE><PRE>class SynchSample {
	int a = 1, b = 2;
	synchronized void hither() {
		a = b;
	}
	synchronized void yon() {
		b = a;
	}
}
</PRE></BLOCKQUOTE><A name=28408></A>Let us again consider the thread that calls 
<CODE>hither</CODE>. According to the rules, this thread must perform a 
<EM>lock</EM> action (on the instance of class <CODE>SynchSample</CODE> on which 
the <CODE>hither</CODE> method is being called) before the body of method 
<CODE>hither</CODE> is executed. This is followed by a <EM>use</EM> of 
<CODE>b</CODE> and then an <EM>assign</EM> of <CODE>a</CODE>. Finally, an 
<EM>unlock</EM> action on that same instance of <CODE>SynchSample</CODE> must be 
performed after the body of method <CODE>hither</CODE> completes. That is the 
bare minimum required to execute a call to the method <CODE>hither</CODE>.
<P><A name=28409></A>As before, a <EM>load</EM> of <CODE>b</CODE> is required, 
which in turn requires a preceding <EM>read</EM> action for <CODE>b</CODE> by 
the main memory. Because the <EM>load</EM> follows the <EM>lock</EM> action, the 
corresponding <EM>read</EM> must also follow the <EM>lock</EM> action.
<P><A name=28410></A>Because an <EM>unlock</EM> action follows the 
<EM>assign</EM> of <CODE>a</CODE>, a <EM>store</EM> action on <CODE>a</CODE> is 
mandatory, which in turn requires a following <EM>write</EM> action for 
<CODE>a</CODE> by the main memory. The <EM>write</EM> must precede the 
<EM>unlock</EM> action.
<P><A name=28411></A>The situation for the thread that calls <CODE>yon</CODE> is 
similar, but with the roles of <CODE>a</CODE> and <CODE>b</CODE> exchanged.
<P><A name=28451></A>The total set of actions may be pictured as follows:
<P>
<CENTER><IMG src="Threads and Locks_files/17.doc.anc1.gif">
<P></CENTER><A name=29170></A>The <EM>lock</EM> and <EM>unlock</EM> actions 
provide further constraints on the order of actions by the main memory; the 
<EM>lock</EM> action by one thread cannot occur between the <EM>lock</EM> and 
<EM>unlock</EM> actions of the other thread. Moreover, the <EM>unlock</EM> 
actions require that the <EM>store</EM> and <EM>write</EM> actions occur. It 
follows that only two sequences are possible:
<P>
<UL><A name=29161></A>
  <LI><EM>write</EM> <CODE>a</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">read <CODE>a</CODE>, <EM>read</EM> 
  <CODE>b</CODE><IMG src="Threads and Locks_files/arrwrite.gif">write 
  <CODE>b</CODE> (then <CODE>ha=2</CODE>, <CODE>hb=2</CODE>, <CODE>ma=2</CODE>, 
  <CODE>mb=2</CODE>, <CODE>ya=2</CODE>, <CODE>yb=2</CODE>) <A name=29162></A>
  <LI><EM>read</EM> <CODE>a</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">write <CODE>a</CODE>, 
  <EM>write</EM> <CODE>b</CODE><IMG 
  src="Threads and Locks_files/arrwrite.gif">read <CODE>b</CODE> (then 
  <CODE>ha=1</CODE>, <CODE>hb=1</CODE>, <CODE>ma=1</CODE>, <CODE>mb=1</CODE>, 
  <CODE>ya=1</CODE>, <CODE>yb=1</CODE>) </LI></UL><A name=28455></A>While the 
resulting state is timing-dependent, it can be seen that the two threads will 
necessarily agree on the values of <CODE>a</CODE> and <CODE>b</CODE>.
<P><A name=29188></A>
<H2>17.11 Example: Out-of-Order Writes</H2><A name=29191></A>This example is 
similar to that in the preceding section, except that one method assigns to both 
variables and the other method reads both variables. Consider a class that has 
class variables <CODE>a</CODE> and <CODE>b</CODE> and methods <CODE>to</CODE> 
and <CODE>fro</CODE>:
<P>
<BLOCKQUOTE><PRE>class Simple {
	int a = 1, b = 2;
	void to() {
		a = 3;
		b = 4;
	}
	void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
</PRE></BLOCKQUOTE><A name=29201></A>Now suppose that two threads are created, 
and that one thread calls <CODE>to</CODE> while the other thread calls 
<CODE>fro</CODE>. What is the required set of actions and what are the ordering 
constraints?
<P><A name=29202></A>Let us consider the thread that calls <CODE>to</CODE>. 
According to the rules, this thread must perform an <EM>assign</EM> of 
<CODE>a</CODE> followed by an <EM>assign</EM> of <CODE>b</CODE>. That is the 
bare minimum required to execute a call to the method <CODE>to</CODE>. Because 
there is no synchronization, it is at the option of the implementation whether 
or not to <EM>store</EM> the assigned values back to main memory! Therefore the 
thread that calls <CODE>fro</CODE> may obtain either <CODE>1</CODE> or 
<CODE>3</CODE> for the value of <CODE>a</CODE>, and independently may obtain 
either <CODE>2</CODE> or <CODE>4</CODE> for the value of <CODE>b</CODE>.
<P><A name=29315></A>Now suppose that <CODE>to</CODE> is 
<CODE>synchronized</CODE> but <CODE>fro</CODE> is not:
<P>
<BLOCKQUOTE><PRE>class SynchSimple {
	int a = 1, b = 2;
	synchronized void to() {
		a = 3;
		b = 4;
	}
	void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
</PRE></BLOCKQUOTE><A name=29316></A>In this case the method <CODE>to</CODE> 
will be forced to <EM>store</EM> the assigned values back to main memory before 
the <EM>unlock</EM> action at the end of the method. The method <CODE>fro</CODE> 
must, of course, <EM>use</EM> <CODE>a</CODE> and <CODE>b</CODE> (in that order) 
and so must <EM>load</EM> values for <CODE>a</CODE> and <CODE>b</CODE> from main 
memory.
<P><A name=29336></A>The total set of actions may be pictured as follows:
<P>
<CENTER><IMG src="Threads and Locks_files/17.doc.anc2.gif">
<P></CENTER><A name=29234></A>Here an arrow from action <EM>A</EM> to action 
<EM>B</EM> indicates that <EM>A</EM> must precede <EM>B</EM>.
<P><A name=29235></A>In what order may the actions by the main memory occur? 
Note that the rules do not require that <EM>write</EM> <CODE>a</CODE> occur 
before <EM>write</EM> <CODE>b</CODE>; neither do they require that <EM>read</EM> 
<CODE>a</CODE> occur before <EM>read</EM> <CODE>b</CODE>. Also, even though 
method <CODE>to</CODE> is <CODE>synchronized</CODE>, method <CODE>fro</CODE> is 
not <CODE>synchronized</CODE>, so there is nothing to prevent the <EM>read</EM> 
actions from occurring between the <EM>lock</EM> and <EM>unlock</EM> actions. 
(The point is that declaring one method <CODE>synchronized</CODE> does not of 
itself make that method behave as if it were atomic.)
<P><A name=29398></A>As a result, the method <CODE>fro</CODE> could still obtain 
either <CODE>1</CODE> or <CODE>3</CODE> for the value of <CODE>a</CODE>, and 
independently could obtain either <CODE>2</CODE> or <CODE>4</CODE> for the value 
of <CODE>b</CODE>. In particular, <CODE>fro</CODE> might observe the value 
<CODE>1</CODE> for <CODE>a</CODE> and <CODE>4</CODE> for <CODE>b</CODE>. Thus, 
even though <CODE>to</CODE> does an <EM>assign</EM> to <CODE>a</CODE> and then 
an <EM>assign</EM> to <CODE>b</CODE>, the <EM>write</EM> actions to main memory 
may be observed by another thread to occur as if in the opposite order.
<P><A name=55976></A>
<P><A name=55977></A>
<P><A name=55978></A>
<P><A name=55979></A>
<P><A name=55980></A>
<P><A name=55985></A>
<P><A name=29431></A>Finally, suppose that <CODE>to</CODE> and <CODE>fro</CODE> 
are both <CODE>synchronized</CODE>:
<P>
<BLOCKQUOTE><PRE>class SynchSynchSimple {
	int a = 1, b = 2;
	synchronized void to() {
		a = 3;
		b = 4;
	}
	synchronized void fro() {
		System.out.println("a= " + a + ", b=" + b);
	}
}
<A name=29386></A>
In this case, the actions of method <CODE>fro</CODE> cannot be interleaved with the actions of method <CODE>to</CODE>, and so <CODE>fro</CODE> will print either "<CODE>a=1, b=2</CODE>" or "<CODE>a=3, b=4</CODE>".<P>
</P></PRE></BLOCKQUOTE><A name=28457></A>
<H2>17.12 Threads</H2><A name=28458></A>Threads are created and managed by the 
built-in classes <CODE>Thread</CODE> and <CODE>ThreadGroup</CODE>. Creating a 
<CODE>Thread</CODE> object creates a thread and that is the only way to create a 
thread. When the thread is created, it is not yet active; it begins to run when 
its <CODE>start</CODE> method is called.
<P><A name=44439></A>Every thread has a <EM>priority</EM>. When there is 
competition for processing resources, threads with higher priority are generally 
executed in preference to threads with lower priority. Such preference is not, 
however, a guarantee that the highest priority thread will always be running, 
and thread priorities cannot be used to reliably implement mutual exclusion.
<P><A name=28460></A>
<H2>17.13 Locks and Synchronization</H2><A name=28461></A>There is a lock 
associated with every object. The Java programming language does not provide a 
way to perform separate <EM>lock</EM> and <EM>unlock</EM> actions; instead, they 
are implicitly performed by high-level constructs that arrange always to pair 
such actions correctly. 
<P><A name=55516></A>Note, however, that the Java virtual machine provides 
separate <EM>monitorenter</EM> and <EM>monitorexit</EM> instructions that 
implement the <EM>lock</EM> and <EM>unlock</EM> actions.
<P><A name=28465></A>The <CODE>synchronized</CODE> statement <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/statements.doc.html#255769">(§14.18)</A> 
computes a reference to an object; it then attempts to perform a <EM>lock</EM> 
action on that object and does not proceed further until the <EM>lock</EM> 
action has successfully completed. (A <EM>lock</EM> action may be delayed 
because the rules about locks can prevent the main memory from participating 
until some other thread is ready to perform one or more <EM>unlock</EM> 
actions.) After the lock action has been performed, the body of the 
<CODE>synchronized</CODE> statement is executed. If execution of the body is 
ever completed, either normally or abruptly, an <EM>unlock</EM> action is 
automatically performed on that same lock.
<P><A name=28469></A>A <CODE>synchronized</CODE> method <A 
href="http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#260369">(§8.4.3.6)</A> 
automatically performs a <EM>lock</EM> action when it is invoked; its body is 
not executed until the <EM>lock</EM> action has successfully completed. If the 
method is an instance method, it locks the lock associated with the instance for 
which it was invoked (that is, the object that will be known as 
<CODE>this</CODE> during execution of the body of the method). If the method is 
<CODE>static</CODE>, it locks the lock associated with the <CODE>Class</CODE> 
object that represents the class in which the method is defined. If execution of 
the method's body is ever completed, either normally or abruptly, an 
<EM>unlock</EM> action is automatically performed on that same lock.
<P><A name=28470></A>Best practice is that if a variable is ever to be assigned 
by one thread and used or assigned by another, then all accesses to that 
variable should be enclosed in <CODE>synchronized</CODE> methods or 
<CODE>synchronized</CODE> statements.
<P><A name=45472></A>The Java programming language does not prevent, nor require 
detection of, deadlock conditions. Programs where threads hold (directly or 
indirectly) locks on multiple objects should use conventional techniques for 
deadlock avoidance, creating higher-level locking primitives that don't 
deadlock, if necessary.
<P><A name=28471></A>
<H2>17.14 Wait Sets and Notification</H2><A name=29596></A>Every object, in 
addition to having an associated lock, has an associated <EM>wait set</EM>, 
which is a set of threads. When an object is first created, its wait set is 
empty.
<P><A name=29597></A>Wait sets are used by the methods <CODE>wait</CODE>, 
<CODE>notify</CODE>, and <CODE>notifyAll</CODE> of class <CODE>Object</CODE>. 
These methods also interact with the scheduling mechanism for threads.
<P><A name=29731></A>The method <CODE>wait</CODE> should be called for an object 
only when the current thread (call it <I>T</I>) has already locked the object's 
lock. Suppose that thread <I>T</I> has in fact performed <EM>N lock</EM> actions 
that have not been matched by <EM>unlock</EM> actions. The <CODE>wait</CODE> 
method then adds the current thread to the wait set for the object, disables the 
current thread for thread scheduling purposes, and performs <EM>N</EM> 
<EM>unlock</EM> actions to relinquish the lock. The thread <I>T</I> then lies 
dormant until one of three things happens:
<P>
<UL><A name=29732></A>
  <LI>Some other thread invokes the <CODE>notify</CODE> method for that object 
  and thread <I>T</I> happens to be the one arbitrarily chosen as the one to 
  notify. <A name=29721></A>
  <LI>Some other thread invokes the <CODE>notifyAll</CODE> method for that 
  object. <A name=29664></A>
  <LI>If the call by thread <I>T</I> to the <CODE>wait</CODE> method specified a 
  timeout interval, the specified amount of real time has elapsed. </LI></UL><A 
name=29669></A>The thread <I>T</I> is then removed from the wait set and 
re-enabled for thread scheduling. It then locks the object again (which may 
involve competing in the usual manner with other threads); once it has gained 
control of the lock, it performs <IMG 
src="Threads and Locks_files/17.doc.anc3.gif"> additional <EM>lock</EM> actions 
and then returns from the invocation of the <CODE>wait</CODE> method. Thus, on 
return from the <CODE>wait</CODE> method, the state of the object's lock is 
exactly as it was when the <CODE>wait</CODE> method was invoked.
<P><A name=29772></A>The <CODE>notify</CODE> method should be called for an 
object only when the current thread has already locked the object's lock. If the 
wait set for the object is not empty, then some arbitrarily chosen thread is 
removed from the wait set and re-enabled for thread scheduling. (Of course, that 
thread will not be able to proceed until the current thread relinquishes the 
object's lock.)
<P><A name=29776></A>The <CODE>notifyAll</CODE> method should be called for an 
object only when the current thread has already locked the object's lock. Every 
thread in the wait set for the object is removed from the wait set and 
re-enabled for thread scheduling. (Of course, those threads will not be able to 
proceed until the current thread relinquishes the object's lock.) <A 
name=48076></A>
<P>
<HR>

<TABLE width="100%" border=0>
  <TBODY>
  <TR>
    <TD><A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jTOC.doc.html">Contents</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/defAssign.doc.html">Prev</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html">Next</A> 
      | <A 
      href="http://java.sun.com/docs/books/jls/second_edition/html/jIX.fm.html">Index</A></TD>
    <TD align=right><I>Java Language Specification</I><BR><FONT size=-1>Second 
      Edition</FONT></TD></TR></TBODY></TABLE><I><A 
href="http://java.sun.com/docs/books/jls/second_edition/html/jcopyright.doc.html">Copyright</A> 
© 2000 Sun Microsystems, Inc. All rights reserved</I> <BR>Please send any 
comments or corrections via our <A 
href="http://developers.sun.com/contact/feedback.jsp?&amp;category=doc&amp;mailsubject=Java%20Language%20Specification%20Feedback">feedback 
form</A> </FONT>
<SCRIPT language=JavaScript 
src="Threads and Locks_files/s_code_remote.js"></SCRIPT>
</BODY></HTML>
